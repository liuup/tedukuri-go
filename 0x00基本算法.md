# 位运算

## [AcWing 89 a^b](https://www.acwing.com/problem/content/91/)

<details>
<summary>Tap to show the code</summary>

```
// 乘法快速幂
package main

import (
    "fmt"
)

func main() {
    var a, b, p int64
		
    fmt.Scanf("%d %d %d", &a, &b, &p)
		
    ans := qpow_for_mod(a, b, p)
		
    fmt.Println(ans)
}

// 循环快速幂 取模
func qpow_for_mod(a, n, mod int64) int64 {
    ans := int64(1 % mod)
    for n > 0 {
        if n&1 == 1 { // n的末位为1，用来判断奇偶性
            ans = int64(ans * a % mod)
        }
        a = int64(a * a % mod)
        n >>= 1
    }
    return ans
}
```
</details>

## [AcWing 90 64位整数乘法](https://www.acwing.com/problem/content/92/)
<details>
<summary>Tap to show the code</summary>

```
package main

import (
    "fmt"
)

func main() {
    var a, b, mod int64
    fmt.Scanf("%d\n%d\n%d", &a, &b, &mod)

    fmt.Println(_64multiply(a, b, mod))
}

// 64位数乘法
func _64multiply(a, b, mod int64) (ans int64) {
    for ; b > 0; b >>= 1 {
        if b&1 == 1 {
            ans = (ans + a) % mod
        }
        a = a * 2 % mod
    }
    return
}
```

</details>

## [AcWing 91 最短Hamilton路径](https://www.acwing.com/problem/content/93/)

<details>
<summary>Tap to show the code</summary>

```
package main

import (
    "fmt"
)

const N int = 20
const M int = 1 << N

var f [M][N]int
var weight [N][N]int

var n int

// acwing 91
func main() {
    fmt.Scan(&n)

    for i := 0; i < n; i++ {
        for j := 0; j < n; j++ {
            fmt.Scan(&weight[i][j])
        }
    }

    for i := 0; i < M; i++ {
        for j := 0; j < N; j++ {
            f[i][j] = 1<<32 - 1
        }
    }

    f[1][0] = 0

    for i := 0; i < 1<<n; i++ { // i表示所有的情况
        for j := 0; j < n; j++ { // j表示走到哪一个点
            if i>>j&1 == 1 {
                for k := 0; k < n; k++ { // k表示走到j这个点之前，以k为终点的最短距离
                    if i>>k&1 == 1 {
                        f[i][j] = min_i(f[i][j], f[i-(1<<j)][k]+weight[k][j])
                    }
                }
            }
        }
    }
    fmt.Println(f[(1<<n)-1][n-1])
}

func min_i(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```
</details>

# 前缀和与差分

## [AcWing 99 激光炸弹](https://www.acwing.com/problem/content/101/)

<details>
<summary>Tap to show the code</summary>

```
package main

import (
	"fmt"
)

var n, r int
var ii, jj, w int

var s [5002][5002]int

// acwing 99
func main() {
	fmt.Scan(&n, &r)

	r = min_i(5001, r)

	for i := 0; i < n; i++ {
		fmt.Scan(&ii, &jj, &w)
		ii++
		jj++
		s[ii][jj] += w
	}

	// 计算前缀和
	for i := 1; i <= 5001; i++ {
		for j := 1; j <= 5001; j++ {
			s[i][j] += s[i-1][j] + s[i][j-1] - s[i-1][j-1]
		}
	}

	ans := 0
	for i := r; i <= 5001; i++ {
		for j := r; j <= 5001; j++ {
			ans = max_i(ans, s[i][j]-s[i-r][j]-s[i][j-r]+s[i-r][j-r])
		}
	}
	fmt.Println(ans)
}

func max_i(a, b int) int {
	if a < b {
		return b
	}
	return a
}

func min_i(a, b int) int {
	if a < b {
		return a
	}
	return b
}
```

</details>